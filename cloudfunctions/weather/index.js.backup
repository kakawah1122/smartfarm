// weatheräº‘å‡½æ•° - å’Œé£å¤©æ°”APIé›†æˆ
const cloud = require('wx-server-sdk')
const crypto = require('crypto')

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})

/**
 * å’Œé£å¤©æ°”é…ç½®
 * è¯·åœ¨è¿™é‡Œé…ç½®æ‚¨çš„å’Œé£å¤©æ°”APIç›¸å…³ä¿¡æ¯
 */
const QWEATHER_CONFIG = {
  // æ‚¨çš„ä¸“ç”¨API Host
  API_HOST: 'n96apwfjn2.re.qweatherapi.com',
  
  // JWTè®¤è¯é…ç½®
  JWT: {
    PROJECT_ID: '2M2BEEB3V5',               // æ‚¨çš„é¡¹ç›®ID
    CREDENTIAL_ID: 'C8B7JUH5V6',            // æ‚¨çš„å‡­æ®IDï¼ˆKIDï¼‰
    PRIVATE_KEY: `-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEIPjx83mg0QC795KAds+Wavn5S9Br7fw/7c4XVF9AferQ
-----END PRIVATE KEY-----`
  }
}

/**
 * ç”ŸæˆJWT Tokenç”¨äºå’Œé£å¤©æ°”APIè®¤è¯
 */
function generateJWT() {
  try {
    const now = Math.floor(Date.now() / 1000)
    
    const header = {
      alg: 'EdDSA',
      kid: QWEATHER_CONFIG.JWT.CREDENTIAL_ID
    }
    
    const payload = {
      sub: QWEATHER_CONFIG.JWT.PROJECT_ID,
      iat: now - 30,
      exp: now + 3600
    }
    
    const base64UrlEncode = (obj) => {
      return Buffer.from(JSON.stringify(obj))
        .toString('base64')
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=/g, '')
    }
    
    const headerEncoded = base64UrlEncode(header)
    const payloadEncoded = base64UrlEncode(payload)
    const data = \`\${headerEncoded}.\${payloadEncoded}\`
    
    const privateKey = crypto.createPrivateKey(QWEATHER_CONFIG.JWT.PRIVATE_KEY)
    const signature = crypto.sign(null, Buffer.from(data), {
      key: privateKey,
      format: 'pem'
    })
    
    const signatureEncoded = signature
      .toString('base64')
      .replace(/\+/g, '-')
      .replace(/\//g, '_')
      .replace(/=/g, '')
    
    return \`\${data}.\${signatureEncoded}\`
  } catch (error) {
    console.error('JWTç”Ÿæˆå¤±è´¥:', error)
    throw new Error('JWTç”Ÿæˆå¤±è´¥: ' + error.message)
  }
}


/**
 * å‘èµ·å’Œé£å¤©æ°”APIè¯·æ±‚
 */
async function qweatherRequest(apiPath, params = {}) {
  const jwt = generateJWT()
  const queryString = new URLSearchParams(params).toString()
  const url = \`https://\${QWEATHER_CONFIG.API_HOST}\${apiPath}\${queryString ? '?' + queryString : ''}\`
  
  console.log(\`è¯·æ±‚å’Œé£å¤©æ°”API: \${url}\`)
  
  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': \`Bearer \${jwt}\`,
        'User-Agent': 'WeChat-MiniProgram-Weather/1.0'
      }
    })
    
    if (!response.ok) {
      throw new Error(\`HTTP Error: \${response.status} \${response.statusText}\`)
    }
    
    const data = await response.json()
    console.log(\`APIå“åº” [\${apiPath}]:\`, data)
    
    if (data.code !== '200') {
      throw new Error(\`API Error: \${data.code} - \${data.message || 'æœªçŸ¥é”™è¯¯'}\`)
    }
    
    return data
  } catch (error) {
    console.error(\`å’Œé£å¤©æ°”APIè¯·æ±‚å¤±è´¥ [\${apiPath}]:\`, error)
    throw error
  }
}

/**
 * é€šè¿‡åæ ‡è·å–åŸå¸‚ä¿¡æ¯
 */
async function getCityByCoordinates(lat, lon) {
  const result = await qweatherRequest('/geo/v2/city/lookup', {
    location: \`\${lon},\${lat}\`,
    lang: 'zh-Hans'
  })
  
  if (result.location && result.location.length > 0) {
    return result.location[0]
  }
  
  throw new Error('æœªæ‰¾åˆ°å¯¹åº”çš„åŸå¸‚ä¿¡æ¯')
}

/**
 * è·å–å®æ—¶å¤©æ°”
 */
async function getCurrentWeather(locationId) {
  return await qweatherRequest('/v7/weather/now', {
    location: locationId,
    lang: 'zh-Hans'
  })
}

/**
 * è·å–é€å°æ—¶å¤©æ°”é¢„æŠ¥ï¼ˆ24å°æ—¶ï¼‰
 */
async function getHourlyForecast(locationId) {
  return await qweatherRequest('/v7/weather/24h', {
    location: locationId,
    lang: 'zh-Hans'
  })
}

/**
 * è·å–é€æ—¥å¤©æ°”é¢„æŠ¥ï¼ˆ7å¤©ï¼‰
 */
async function getDailyForecast(locationId) {
  return await qweatherRequest('/v7/weather/7d', {
    location: locationId,
    lang: 'zh-Hans'
  })
}

/**
 * è·å–å¤©æ°”é¢„è­¦
 */
async function getWeatherWarning(locationId) {
  try {
    return await qweatherRequest('/v7/warning/now', {
      location: locationId,
      lang: 'zh-Hans'
    })
  } catch (error) {
    console.log('è·å–å¤©æ°”é¢„è­¦å¤±è´¥ï¼ˆå¯èƒ½æ˜¯æ²¡æœ‰é¢„è­¦ä¿¡æ¯ï¼‰:', error.message)
    return { warning: [] }
  }
}

/**
 * è·å–ç©ºæ°”è´¨é‡ï¼ˆä½¿ç”¨åæ ‡ï¼‰
 */
async function getAirQuality(lat, lon) {
  try {
    return await qweatherRequest('/v7/air/now', {
      location: \`\${lon},\${lat}\`,
      lang: 'zh-Hans'
    })
  } catch (error) {
    console.log('è·å–ç©ºæ°”è´¨é‡å¤±è´¥:', error.message)
    return { now: {} }
  }
}

/**
 * è·å–å¤©æ°”è¡¨æƒ…å›¾æ ‡
 */
function getWeatherEmoji(weather) {
  const emojiMap = {
    'æ™´': 'â˜€ï¸',
    'å¤šäº‘': 'â›…',
    'é˜´': 'â˜ï¸',
    'å°é›¨': 'ğŸŒ¦ï¸',
    'ä¸­é›¨': 'ğŸŒ§ï¸',
    'å¤§é›¨': 'â›ˆï¸',
    'é›·é˜µé›¨': 'â›ˆï¸',
    'é›ª': 'â„ï¸',
    'å°é›ª': 'â„ï¸',
    'ä¸­é›ª': 'â„ï¸',
    'å¤§é›ª': 'â„ï¸',
    'é›¾': 'ï¿½ï¿½ï¸',
    'éœ¾': 'ğŸ˜·',
    'æ²™å°˜æš´': 'ğŸŒªï¸',
    'æµ®å°˜': 'ï¿½ï¿½ï¸',
    'æ‰¬æ²™': 'ğŸŒªï¸'
  }
  
  return emojiMap[weather] || 'ğŸŒ¤ï¸'
}

/**
 * è·å–å®Œæ•´å¤©æ°”æ•°æ®
 */
async function getCompleteWeatherData(lat, lon) {
  try {
    console.log('å¼€å§‹è·å–å®Œæ•´å¤©æ°”æ•°æ®ï¼Œåæ ‡:', { lat, lon })
    
    // 1. é¦–å…ˆé€šè¿‡åæ ‡è·å–åŸå¸‚ä¿¡æ¯
    const cityInfo = await getCityByCoordinates(lat, lon)
    const locationId = cityInfo.id
    
    console.log('è·å–åˆ°åŸå¸‚ä¿¡æ¯:', cityInfo)
    
    // 2. å¹¶è¡Œè·å–å„ç§å¤©æ°”æ•°æ®
    const [
      currentWeather,
      hourlyForecast,
      dailyForecast,
      weatherWarning,
      airQuality
    ] = await Promise.all([
      getCurrentWeather(locationId),
      getHourlyForecast(locationId),
      getDailyForecast(locationId),
      getWeatherWarning(locationId),
      getAirQuality(lat, lon)
    ])
    
    // 3. æ•´ç†æ•°æ®æ ¼å¼ï¼ŒåŒ¹é…å‰ç«¯æœŸæœ›
    const processedData = {
      locationInfo: {
        province: cityInfo.adm1 || cityInfo.country,
        city: cityInfo.adm2 || cityInfo.name,
        district: cityInfo.name,
        latitude: lat,
        longitude: lon
      },
      current: {
        temperature: parseInt(currentWeather.now.temp) || 0,
        humidity: parseInt(currentWeather.now.humidity) || 0,
        feelsLike: parseInt(currentWeather.now.feelsLike) || parseInt(currentWeather.now.temp) || 0,
        windDirection: currentWeather.now.windDir || 'æ— é£',
        windScale: currentWeather.now.windScale || '0çº§',
        windSpeed: parseInt(currentWeather.now.windSpeed) || 0,
        visibility: parseInt(currentWeather.now.vis) || 0,
        pressure: parseInt(currentWeather.now.pressure) || 0,
        updateTime: currentWeather.updateTime || new Date().toISOString()
      },
      condition: {
        text: currentWeather.now.text || 'æœªçŸ¥',
        emoji: getWeatherEmoji(currentWeather.now.text)
      },
      hourly: hourlyForecast.hourly || [],
      daily: dailyForecast.daily || [],
      warning: weatherWarning.warning || [],
      air: airQuality.now || {}
    }
    
    console.log('æ•°æ®å¤„ç†å®Œæˆ')
    return {
      success: true,
      data: processedData
    }
    
  } catch (error) {
    console.error('è·å–å®Œæ•´å¤©æ°”æ•°æ®å¤±è´¥:', error)
    return {
      success: false,
      error: {
        message: error.message,
        code: error.code || 'UNKNOWN_ERROR'
      }
    }
  }
}

// æ›´æ–°åçš„mainå‡½æ•°
exports.main = async (event, context) => {
  console.log('weatheräº‘å‡½æ•°è¢«è°ƒç”¨ï¼Œå‚æ•°:', event)
  
  const { action, lat, lon } = event
  
  // æ£€æŸ¥é…ç½®
  if (QWEATHER_CONFIG.JWT.PROJECT_ID === 'YOUR_PROJECT_ID' || 
      QWEATHER_CONFIG.JWT.CREDENTIAL_ID === 'YOUR_CREDENTIAL_ID' ||
      QWEATHER_CONFIG.JWT.PRIVATE_KEY.includes('YOUR_ED25519_PRIVATE_KEY_HERE')) {
    return {
      success: false,
      error: {
        message: 'è¯·å…ˆåœ¨index.jsä¸­é…ç½®æ‚¨çš„å’Œé£å¤©æ°”APIè®¤è¯ä¿¡æ¯ï¼ˆPROJECT_IDã€CREDENTIAL_IDã€PRIVATE_KEYï¼‰',
        code: 'CONFIG_REQUIRED'
      }
    }
  }
  
  try {
    switch (action) {
      case 'getCompleteWeather':
        if (!lat || !lon) {
          throw new Error('ç¼ºå°‘å¿…è¦çš„ç»çº¬åº¦å‚æ•°')
        }
        return await getCompleteWeatherData(parseFloat(lat), parseFloat(lon))
      
      default:
        throw new Error(\`ä¸æ”¯æŒçš„æ“ä½œ: \${action}\`)
    }
  } catch (error) {
    console.error('äº‘å‡½æ•°æ‰§è¡Œå¤±è´¥:', error)
    return {
      success: false,
      error: {
        message: error.message,
        code: error.code || 'UNKNOWN_ERROR'
      }
    }
  }
}
